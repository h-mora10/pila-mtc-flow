pre{
	var a: new ModelMM!Architecture;
	var bm: new ModelMM!BusinessModel;
	
	bm.dataTypes.add(new ModelMM!String);
	bm.dataTypes.add(new ModelMM!Integer);
	bm.dataTypes.add(new ModelMM!Float);
	bm.dataTypes.add(new ModelMM!Boolean);
	bm.dataTypes.add(new ModelMM!Date);
	bm.dataTypes.add(new ModelMM!Enum);
	
	a.businessModel = bm;
}

rule ServiceOp2Entity
	transform
		s:GrammarMM!ServiceOperator
	to
		t:ModelMM!Entity{
			bm.entities.add(t);
			t.name = s.name;
			t.childrenEntities = s.superEntities.equivalent();
			t.childrenEntities.addAll(s.services.equivalent());
			t.attributes = s.attributes.equivalent();
		}
		
rule SuperEnt2Entity
	transform
		s:GrammarMM!SuperEntity
	to
		t:ModelMM!Entity{
			t.name = s.name;
			t.childrenEntities = s.entities.equivalent();
			t.childrenEntities.add(s.pays.equivalent());
			t.attributes = s.attributes.equivalent();
		}
		
rule BusinessEnt2Entity
	transform
		s:GrammarMM!BusinessEntity
	to
		t:ModelMM!Entity{
			t.name = s.name;
			t.attributes = s.attributes.equivalent();
		}
		
rule Pay2Entity
	transform
		s:GrammarMM!Pay
	to
		t:ModelMM!Entity{
			t.name = s.name;
			t.attributes = s.attributes.equivalent();
		}
		
rule Service2Entity
	transform
		s:GrammarMM!Service
	to
		t:ModelMM!Entity{
			t.name = s.name;
			t.attributes = s.displayName.equivalent();
			t.methods = s.calculate.equivalent();
		}
		
rule Calculate2Method
	transform
		s:GrammarMM!Calculate
	to
		t:ModelMM!Method{
			t.name = s.name;
			t.body = s.toBody();
		}
				
rule StringAttr2Attr
	transform
		s:GrammarMM!StringValue
	to
		t:ModelMM!Attribute{
			t.name = s.name;
			t.attType = bm.dataTypes[0];
		}

rule IntegerAttr2Attr
	transform
		s:GrammarMM!IntegerValue
	to
		t:ModelMM!Attribute{
			t.name = s.name;
			t.attType = bm.dataTypes[1];
		}

rule BooleanAttr2Attr
	transform
		s:GrammarMM!BooleanValue
	to
		t:ModelMM!Attribute{
			t.name = s.name;
			t.attType = bm.dataTypes[3];
		}
		
rule FloatAttr2Attr
	transform
		s:GrammarMM!FloatValue
	to
		t:ModelMM!Attribute{
			t.name = s.name;
			t.attType = bm.dataTypes[2];
		}
		
rule DateAttr2Attr
	transform
		s:GrammarMM!Date
	to
		t:ModelMM!Attribute{
			t.name = s.name;
			t.attType = bm.dataTypes[4];
		}
		
rule EnumAttr2Attr
	transform
		s:GrammarMM!Enum
	to
		t:ModelMM!Attribute{
			t.name = s.name;
			t.value = s.items;
			t.attType = bm.dataTypes[5];
		}

rule ComplexAttr2Entity
	transform
		s:GrammarMM!Complex
	to
		t:ModelMM!Entity{
			t.name = s.name;
			t.attributes = s.attributes.equivalent();			
		}
			
operation GrammarMM!Calculate toBody(): ModelMM!Body{
	var body : new ModelMM!Body;
	var contents : String;
	var level : Integer;
	level = 0;
	for (cond in self.conditions){
		contents = cond.transformStatement(level);
	}
	body.content = contents;
	body.content.println();
	return body;
}

operation GrammarMM!Statement transformStatement(level : Integer) : String{
	var contents : String;
	
	if (self.isTypeOf(GrammarMM!If)){
		contents += self.transformIf();
	}
	if (self.isTypeOf(GrammarMM!Variable)){
		contents += self.name;
		contents += " = ";
		contents += self.value;
		contents += "\n";
	}
	if (self.isTypeOf(GrammarMM!Return)){
		contents += "return ";
		contents += self.value.transformOperation();
		contents += "\n";
	}
	
	return contents;
}

operation GrammarMM!If transformIf() : String{
	var contents : String;
	
	contents += "if ";
	
	if(not self.expressions.isEmpty()){
		for (exp in self.expressions){
			contents += exp.transformExpression();
		}
	}
	
	if(not self.statements.isEmpty()){
		for (st in self.statements){
			contents += st.transformStatement(1);
		}
	}
	
	if(not self.esleIf.isEmpty()){
		for (elf in self.esleIf){
			if(not elf.expressions.isEmpty()){		
				for(exp in elf.expressions){
					contents += exp.transformExpression();
				}
			}
			if(not elf.statements.isEmpty()){
				for(st in elf.statements){
					contents += st.transformStatement(1);
				}
			}
		}
	}
	
	if(self.els.isDefined()){
		for (el in self.els){
			if(not el.statements.isEmpty()){
				for(st in el.statements){
					contents += st.transformStatement(1);
				}
			}
		}
	}

	return contents;
}

operation GrammarMM!Expression transformExpression() : String{
	var contents : String;

	if(self.elementLeft.isDefined()){
		contents += self.elementLeft.element;
		contents += " ";
	}
	if(self.comparator.isDefined()){
		contents += self.comparator;
		contents += " ";
	}
	if(self.elementRight.isDefined()){
		contents += self.elementRight.element;
	}
	contents += "\n";
	
	return contents;
}

operation GrammarMM!Operation transformOperation() : String{
	var contents : String;
	
	if(self.valueLeft.isDefined()){
		contents += self.valueLeft;
		contents += " ";
	}
	if(self.operator.isDefined()){
		contents += self.operator;
		contents += " ";
	}
	if(self.valueRight.isDefined()){
		contents += self.valueRight;
	}
	
	return contents;
}